<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="generator" content="Jekyll v3.3.0">

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Blender" />
		<!-- Begin Jekyll SEO tag v2.1.0 -->
<title>Unified Parsing &amp; Printing - Blender</title>
<meta property="og:title" content="Unified Parsing &amp; Printing" />
<meta name="description" content="BiGrammar is a DSL that allows the user to define both a parser and a pretty printer at the same time. Operators and methods in BiGrammar will often have an effect on both the parser and the printer, both can sometimes influence only one of both." />
<meta property="og:description" content="BiGrammar is a DSL that allows the user to define both a parser and a pretty printer at the same time. Operators and methods in BiGrammar will often have an effect on both the parser and the printer, both can sometimes influence only one of both." />
<link rel="canonical" href="http://localhost:4000/grammar/unified-parsing-and-printing/" />
<meta property="og:url" content="http://localhost:4000/grammar/unified-parsing-and-printing/" />
<meta property="og:site_name" content="Blender" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-26T00:01:26+01:00" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "Article",
"headline": "Unified Parsing &amp; Printing",
"datePublished": "2017-11-26T00:01:26+01:00",
"description": "BiGrammar is a DSL that allows the user to define both a parser and a pretty printer at the same time. Operators and methods in BiGrammar will often have an effect on both the parser and the printer, both can sometimes influence only one of both.",
"publisher": {"@type": "Organization",
"logo": {"@type": "ImageObject",
"url": "http://localhost:4000/favicon.png"}},
"url": "http://localhost:4000/grammar/unified-parsing-and-printing/"}</script>
<!-- End Jekyll SEO tag -->


		
	</head>

	<body>
		<header>
			<h1>
				<a href="/"><img src="/images/favicon.png" width="40" height="40" alt="Blender logo"></a>
				Blender
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">Blender</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level ">
							<a href="">Core</a>
							<ul>
								
								
									
								
									
										<li class="nav-item "><a href="/core/delta/">Delta</a></li>
									
								
									
										<li class="nav-item "><a href="/core/what-is-a-language/">What is a language?</a></li>
									
								
									
								
									
								
									
										<li class="nav-item "><a href="/core/effective-blender/">Effective Blender</a></li>
									
								
									
										<li class="nav-item "><a href="/core/sandbox/">Sandbox</a></li>
									
								
									
								
									
								
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							<a href="/grammar/bigrammar/">Grammar</a>
							<ul>
								
								
									
										<li class="nav-item "><a href="/grammar/bigrammar/">BiGrammar</a></li>
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
										<li class="nav-item current"><a href="/grammar/unified-parsing-and-printing/">Unified Parsing & Printing</a></li>
									
								
									
										<li class="nav-item "><a href="/grammar/modularity/">Modularity</a></li>
									
								
									
										<li class="nav-item "><a href="/grammar/whole-language-transformation/">Whole language transformation</a></li>
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							<a href="/grammar/bigrammar/">Java</a>
							<ul>
								
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							<a href="/grammar/bigrammar/">Practical</a>
							<ul>
								
								
									
								
									
								
									
								
									
										<li class="nav-item "><a href="/practical/build/">Build instructions</a></li>
									
								
									
										<li class="nav-item "><a href="/practical/contributions/">How to contribute</a></li>
									
								
									
								
									
								
									
								
									
								
									
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							<a href="/grammar/bigrammar/">Discussion</a>
							<ul>
								
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
									
								
							</ul>
						</li>
					
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>Grammar</h2>
				<h3>Unified Parsing & Printing</h3>
			</div>
			<article class="content">
				<p>BiGrammar is a DSL that allows the user to define both a parser and a pretty printer at the same time. Operators and methods in BiGrammar will often have an effect on both the parser and the printer, both can sometimes influence only one of both.</p>

<h3 id="example">Example</h3>
<p>Here follows an example of a small piece of grammar defined using BiGrammar:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="s">"while"</span> <span class="o">~</span> <span class="n">expression</span><span class="o">.</span><span class="n">inParenthesis</span><span class="o">.</span><span class="n">as</span><span class="o">(</span><span class="nc">Condition</span><span class="o">)</span> <span class="o">~~</span> <span class="s">"{"</span> <span class="o">%</span>
        <span class="n">statement</span><span class="o">.</span><span class="n">manyVertical</span><span class="o">.</span><span class="n">indent</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">as</span><span class="o">(</span><span class="nc">Body</span><span class="o">)</span> <span class="o">%</span>
        <span class="s">"}"</span> <span class="n">asNode</span> <span class="nc">While</span>
</code></pre>
</div>
<p>The grammars for <code class="highlighter-rouge">expression</code> and <code class="highlighter-rouge">statement</code> have been left out for brevity.</p>

<p>The operators have the following meaning:
- <code class="highlighter-rouge">~</code> is horizontal separation.
- <code class="highlighter-rouge">~~</code> is the same as <code class="highlighter-rouge">~</code> when parsing, but when printing adds a space between the left and right grammar. 
- <code class="highlighter-rouge">%</code> is vertical separation.
- <code class="highlighter-rouge">as</code> binds the grammar to a field in the AST
- <code class="highlighter-rouge">asNode</code> binds the grammar to a node in the AST
- <code class="highlighter-rouge">indent</code> indents the grammar on which it is applied, but only when printing.</p>

<p>With the defined BiGrammar, we can parse the following program (ugly formatting is intentional)
<code class="highlighter-rouge">java
while (i){
  i--; x += 2;
}
</code></p>

<p>yielding this AST</p>

<div class="language-yml highlighter-rouge"><pre class="highlight"><code><span class="s">Class</span><span class="pi">:</span> <span class="s">While</span>
<span class="s">Condition</span><span class="pi">:</span> 
  <span class="s">Class</span><span class="pi">:</span> <span class="s">Variable</span>
  <span class="s">Name</span><span class="pi">:</span> <span class="s">i</span>
<span class="s">Body</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Class</span><span class="pi">:</span> <span class="s">Decrement</span>
    <span class="s">Target</span><span class="pi">:</span> <span class="s">i</span>
  <span class="pi">-</span> <span class="s">Class</span><span class="pi">:</span> <span class="s">PlusEquals</span>
    <span class="s">Target</span><span class="pi">:</span> <span class="s">x</span>
    <span class="s">Value</span><span class="pi">:</span> 
      <span class="s">Class</span><span class="pi">:</span> <span class="s">Constant</span>
      <span class="s">Value</span><span class="pi">:</span> <span class="s">2</span>  
</code></pre>
</div>
<p>which can be pretty printed to
<code class="highlighter-rouge">Java
while(i) {
  i--;
  x += 2;
}
</code></p>

<h3 id="choice-ignore-and-value">Choice, ignore and value</h3>
<p>Here is another example grammar:
<code class="highlighter-rouge">scala
"yes" ~&gt; value(true) | "no" ~&gt; value(false)
</code>
- <code class="highlighter-rouge">|</code> is the choice operator. If the left grammar fails to parse/print, then the right grammar is used.
- The <code class="highlighter-rouge">&lt;</code> and <code class="highlighter-rouge">&gt;</code> symbols can be added to the end of existing operators to create a variation, <code class="highlighter-rouge">&lt;</code> means ignore the result of the grammar to the right, so <code class="highlighter-rouge">a ~&gt; b</code> means <code class="highlighter-rouge">a</code> left of <code class="highlighter-rouge">b</code>, but ignore the result of <code class="highlighter-rouge">a</code> when parsing.
- <code class="highlighter-rouge">value</code> has no effect on the syntax, it will produce a value when parsing and consume one while printing.</p>

<h3 id="regex-and-map">Regex and map</h3>
<p>Here is another example:
<code class="highlighter-rouge">scala
new RegexGrammar("""-?\d+""".r).map(
  afterParsing = (s: String) =&gt; Integer.parseInt(s), 
  beforePrinting =  (i: Int) =&gt; Some(i.toString)
)
</code>
- <code class="highlighter-rouge">RegexGrammar</code> turns a regular expression into a grammar
- <code class="highlighter-rouge">map</code> transforms the grammarâ€™s value using a bidirectional mapping. The argument <code class="highlighter-rouge">beforePrinting</code> returns an <code class="highlighter-rouge">Option</code> to allow printing to fail if the passed value does not belong to the grammar.</p>

<h3 id="next">Next</h3>
<p><a href="http://keyboarddrummer.github.io/Blender/bigrammar/modularity/">Read how BiGrammar supports modular language design</a></p>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
